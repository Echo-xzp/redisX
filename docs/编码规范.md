# 编码规范文档

## 文档说明

本文档定义 redisX 项目的编码规范，包括代码风格、命名规范、注释规范、错误处理等。所有开发人员应遵循本规范，确保代码的一致性和可维护性。

**项目名称**：redisX  
**编程语言**：Go  
**规范版本**：v1.0  

---

## 1. 代码风格

### 1.1 遵循 Go 官方规范

- 遵循 [Effective Go](https://golang.org/doc/effective_go.html) 和 [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments)
- 使用 `gofmt` 格式化代码（推荐使用 `goimports`，自动整理 imports）
- 使用 `golint` 检查代码风格

### 1.2 格式化工具

**推荐的 IDE 配置：**
- VS Code：安装 Go 插件，启用 `format on save`
- GoLand：启用 `go fmt` 和 `goimports`

**命令行工具：**
```bash
# 格式化代码
go fmt ./...

# 格式化并整理 imports
goimports -w .

# 检查代码风格
golint ./...
```

---

## 2. 命名规范

### 2.1 包名（Package）

- **小写字母**，简短且有意义的名称
- 不使用下划线或驼峰
- 避免使用通用名称（如 `util`、`common`）

**示例：**
```go
package storage  // ✅ 正确
package protocol // ✅ 正确
package util     // ❌ 避免
package common   // ❌ 避免
```

### 2.2 变量和常量

**变量命名：**
- 使用驼峰命名（camelCase）
- 简短且有意义
- 布尔变量使用 `is`、`has`、`can` 等前缀

**示例：**
```go
// ✅ 正确
var clientConn net.Conn
var isExpired bool
var maxConnections int
var connCount int64

// ❌ 避免
var c net.Conn              // 太简短
var expired_flag bool       // 不使用下划线
var MAX_CONNECTIONS int     // 常量使用大写
```

**常量命名：**
- 使用大写字母和下划线
- 如果是包级别常量，使用前缀避免冲突

**示例：**
```go
// ✅ 正确
const (
    DefaultPort = 6379
    MaxKeyLength = 512
    DefaultTimeout = 30 * time.Second
)

const DefaultAddr = ":6379"
```

### 2.3 函数和方法

**函数命名：**
- 使用驼峰命名
- 公开函数（首字母大写）：清晰描述功能
- 私有函数（首字母小写）：简洁即可

**示例：**
```go
// ✅ 正确
func Start() error              // 公开函数，清晰
func handleConnection() error   // 私有函数，简洁
func parseRESPArray() ([]string, error)  // 私有函数

// ❌ 避免
func start() error              // 应该是 Start（如果要导出）
func HandleConn() error         // 不够清晰
```

**方法接收者命名：**
- 使用类型名的首字母（小写）
- 如果只有一个接收者，统一使用单字母

**示例：**
```go
// ✅ 正确
func (s *Server) Start() error
func (c *Connection) Read() error
func (p *RESPParser) Parse() error

// ❌ 避免
func (server *Server) Start() error     // 太冗长
func (conn *Connection) Read() error    // 不一致
```

### 2.4 类型命名

**结构体：**
- 使用驼峰命名，首字母大写（公开类型）
- 名称应该是名词

**示例：**
```go
// ✅ 正确
type Server struct { }
type Connection struct { }
type RESPParser struct { }

// ❌ 避免
type server struct { }        // 如果需要在包外使用
type connectionHandler struct { }  // 太长
```

**接口：**
- 使用驼峰命名，首字母大写
- 接口名通常是动词 + er，或者描述性的名词

**示例：**
```go
// ✅ 正确
type Storage interface { }
type Parser interface { }
type Encoder interface { }

// ❌ 避免
type IStorage interface { }   // 不使用 I 前缀
```

---

## 3. 代码组织

### 3.1 文件组织

**目录结构：**
```
internal/
  ├── server/
  │   ├── server.go        # Server 结构体和核心方法
  │   ├── connection.go    # Connection 结构体和方法
  │   └── server_test.go   # 测试文件
  ├── protocol/
  │   ├── parser.go        # RESP 解析器
  │   ├── encoder.go       # RESP 编码器
  │   └── protocol_test.go
  ├── command/
  │   ├── router.go        # 命令路由
  │   ├── handlers.go      # 命令处理器
  │   └── command_test.go
  └── storage/
      ├── storage.go       # 存储引擎
      ├── entry.go         # Entry 结构体
      └── storage_test.go
```

**文件命名：**
- 使用小写字母和下划线（或驼峰）
- 测试文件：`*_test.go`
- 示例文件：`*_example.go`

### 3.2 导入顺序

1. 标准库
2. 第三方库
3. 项目内部包

**示例：**
```go
import (
    // 标准库
    "fmt"
    "net"
    "sync"
    "time"

    // 第三方库
    "github.com/sirupsen/logrus"

    // 项目内部包
    "redisx/internal/protocol"
    "redisx/internal/storage"
)
```

### 3.3 代码顺序

在文件内部，按以下顺序组织代码：

1. 包声明
2. 导入
3. 常量
4. 变量
5. 类型定义
6. 函数和方法

**示例：**
```go
package storage

import (
    "sync"
    "time"
)

const (
    DefaultCleanInterval = 1 * time.Minute
)

var (
    defaultStorage *Storage
)

type Entry struct {
    Value      string
    ExpireTime *time.Time
}

type Storage struct {
    mu   sync.RWMutex
    data map[string]*Entry
}

func New() *Storage {
    // ...
}
```

---

## 4. 注释规范

### 4.1 包注释

- 每个包都应该有包注释
- 包注释位于文件开头，`package` 声明之前
- 简要描述包的功能

**示例：**
```go
// Package storage provides a thread-safe key-value storage engine.
// It supports basic operations like Get, Set, Delete, and expiration.
package storage
```

### 4.2 公开函数/方法注释

- 所有公开的函数、方法、类型都应该有注释
- 注释以函数/类型名开头，描述功能
- 使用完整句子，以句号结尾

**示例：**
```go
// Start starts the server and begins accepting connections.
// It returns an error if the server fails to start.
func (s *Server) Start() error {
    // ...
}

// Storage provides a thread-safe key-value storage.
type Storage struct {
    // ...
}

// Get retrieves the value for the given key.
// It returns the value and a boolean indicating whether the key exists.
func (s *Storage) Get(key string) (string, bool) {
    // ...
}
```

### 4.3 复杂逻辑注释

- 对于复杂的算法或业务逻辑，添加注释说明
- 解释"为什么"而非"做什么"（代码本身应该说明做什么）

**示例：**
```go
// 懒删除策略：在访问时检查过期，避免额外的后台任务开销
if entry.IsExpired() {
    s.Delete(key)
    return "", false
}

// 使用读写锁：读操作并发，写操作独占
s.mu.RLock()  // 多个读操作可以并发
defer s.mu.RUnlock()
```

### 4.4 TODO 和 FIXME

- 使用 `TODO` 标记待办事项
- 使用 `FIXME` 标记需要修复的问题
- 格式：`// TODO(username): 描述`

**示例：**
```go
// TODO(张三): 实现定期清理过期键的后台任务
// FIXME: 处理网络异常时的资源泄漏问题
```

---

## 5. 错误处理

### 5.1 错误返回

- 函数可能失败时，返回 `error` 作为最后一个返回值
- 错误应该提供足够的上下文信息

**示例：**
```go
// ✅ 正确
func (s *Server) Start() error {
    listener, err := net.Listen("tcp", s.addr)
    if err != nil {
        return fmt.Errorf("failed to listen on %s: %w", s.addr, err)
    }
    // ...
}

// ❌ 避免
func (s *Server) Start() error {
    listener, err := net.Listen("tcp", s.addr)
    if err != nil {
        return err  // 缺少上下文
    }
}
```

### 5.2 错误检查

- **总是检查错误**，不要忽略
- 如果确实需要忽略，添加注释说明原因

**示例：**
```go
// ✅ 正确
if err != nil {
    log.Printf("failed to close connection: %v", err)
    return err
}

// 如果确实需要忽略（很少见）
_, _ = conn.Write(data)  // 忽略错误，连接可能已关闭
```

### 5.3 错误包装

- 使用 `fmt.Errorf` 和 `%w` 动词包装错误
- 保留原始错误链，便于调试

**示例：**
```go
// ✅ 正确
if err := parseRequest(); err != nil {
    return fmt.Errorf("failed to parse request: %w", err)
}
```

### 5.4 自定义错误

- 对于需要客户端判断的错误类型，定义自定义错误

**示例：**
```go
var (
    ErrKeyNotFound = errors.New("key not found")
    ErrInvalidCommand = errors.New("invalid command")
)

// 使用
if !exists {
    return nil, ErrKeyNotFound
}
```

---

## 6. 并发安全

### 6.1 锁的使用

- 明确锁的职责和范围
- 使用 `defer` 确保锁被释放
- 避免死锁（注意锁的获取顺序）

**示例：**
```go
// ✅ 正确
func (s *Storage) Get(key string) (string, bool) {
    s.mu.RLock()
    defer s.mu.RUnlock()  // 确保释放锁
    
    entry, exists := s.data[key]
    if !exists || entry.IsExpired() {
        return "", false
    }
    return entry.Value, true
}

// ❌ 避免
func (s *Storage) Get(key string) (string, bool) {
    s.mu.RLock()
    entry, exists := s.data[key]
    s.mu.RUnlock()  // 可能提前返回，忘记解锁
    return entry.Value, exists
}
```

### 6.2 原子操作

- 对于简单的计数器等，优先使用 `sync/atomic`
- 避免为简单操作使用锁

**示例：**
```go
// ✅ 正确
var connCount int64

func incrementConnCount() {
    atomic.AddInt64(&connCount, 1)
}

// ❌ 避免
var mu sync.Mutex
var connCount int64

func incrementConnCount() {
    mu.Lock()
    connCount++
    mu.Unlock()  // 过度使用锁
}
```

---

## 7. 性能考虑

### 7.1 字符串操作

- 大量字符串拼接使用 `strings.Builder`
- 避免在循环中进行字符串拼接

**示例：**
```go
// ✅ 正确
var builder strings.Builder
for _, s := range strings {
    builder.WriteString(s)
}
result := builder.String()

// ❌ 避免
result := ""
for _, s := range strings {
    result += s  // 性能差
}
```

### 7.2 内存分配

- 避免不必要的内存分配
- 考虑使用对象池（`sync.Pool`）复用对象

**示例：**
```go
// 对象池示例（如果频繁分配 Entry）
var entryPool = sync.Pool{
    New: func() interface{} {
        return &Entry{}
    },
}

func getEntry() *Entry {
    return entryPool.Get().(*Entry)
}

func putEntry(e *Entry) {
    e.Value = ""
    e.ExpireTime = nil
    entryPool.Put(e)
}
```

### 7.3 缓冲区使用

- 网络 I/O 使用 `bufio.Reader` 和 `bufio.Writer`
- 减少系统调用次数

**示例：**
```go
reader := bufio.NewReader(conn)
writer := bufio.NewWriter(conn)

// 批量写入后刷新
writer.WriteString("response1")
writer.WriteString("response2")
writer.Flush()  // 一次性写入
```

---

## 8. 测试规范

### 8.1 测试文件命名

- 测试文件：`*_test.go`
- 测试函数：`TestXxx`

**示例：**
```go
// storage_test.go
func TestStorage_Get(t *testing.T) {
    // ...
}
```

### 8.2 测试函数命名

- 使用 `Test` 前缀
- 格式：`Test<类型>_<方法>` 或 `Test<函数名>`

**示例：**
```go
func TestStorage_Get(t *testing.T)
func TestStorage_Set(t *testing.T)
func TestParseRESPArray(t *testing.T)
```

### 8.3 表驱动测试

- 对于多场景测试，使用表驱动测试

**示例：**
```go
func TestStorage_Get(t *testing.T) {
    tests := []struct {
        name      string
        key       string
        wantValue string
        wantExists bool
    }{
        {
            name:       "existing key",
            key:        "key1",
            wantValue:  "value1",
            wantExists: true,
        },
        {
            name:       "non-existing key",
            key:        "key2",
            wantValue:  "",
            wantExists: false,
        },
    }
    
    storage := New()
    storage.Set("key1", "value1", nil)
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            gotValue, gotExists := storage.Get(tt.key)
            if gotValue != tt.wantValue {
                t.Errorf("Get() gotValue = %v, want %v", gotValue, tt.wantValue)
            }
            if gotExists != tt.wantExists {
                t.Errorf("Get() gotExists = %v, want %v", gotExists, tt.wantExists)
            }
        })
    }
}
```

### 8.4 并发测试

- 对于并发安全的代码，编写并发测试

**示例：**
```go
func TestStorage_Concurrent(t *testing.T) {
    storage := New()
    
    var wg sync.WaitGroup
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", i)
            storage.Set(key, "value", nil)
            storage.Get(key)
        }(i)
    }
    wg.Wait()
}
```

---

## 9. 代码审查检查清单

### 9.1 功能正确性

- [ ] 代码逻辑正确
- [ ] 边界情况处理
- [ ] 错误处理完整
- [ ] 并发安全（如果涉及并发）

### 9.2 代码质量

- [ ] 代码格式符合规范（`gofmt`）
- [ ] 命名清晰有意义
- [ ] 注释充分（公开 API）
- [ ] 没有重复代码

### 9.3 性能

- [ ] 无明显性能问题
- [ ] 内存使用合理
- [ ] 没有不必要的分配

### 9.4 测试

- [ ] 有单元测试
- [ ] 测试覆盖率合理
- [ ] 边界情况有测试

---

## 10. Git 提交规范

### 10.1 提交消息格式

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Type 类型：**
- `feat`: 新功能
- `fix`: 修复 Bug
- `docs`: 文档更新
- `style`: 代码格式调整（不影响功能）
- `refactor`: 重构
- `test`: 测试相关
- `chore`: 构建/工具相关

**示例：**
```
feat(storage): 实现过期键的懒删除机制

在 Get 操作时检查键是否过期，如果过期则删除并返回不存在。
这避免了额外的后台任务开销。

Closes #123
```

### 10.2 提交频率

- 功能完整时提交
- 每个提交应该是独立的、可测试的
- 避免大型提交（超过 300 行变更）

---

## 11. 常见问题和最佳实践

### 11.1 避免全局变量

- 尽量使用依赖注入，避免全局状态
- 如果必须使用，确保线程安全

**示例：**
```go
// ✅ 正确：通过参数传递
func NewServer(storage *Storage) *Server {
    return &Server{storage: storage}
}

// ❌ 避免：全局变量
var globalStorage *Storage

func NewServer() *Server {
    return &Server{storage: globalStorage}
}
```

### 11.2 避免过度抽象

- 第一阶段以简单直接为主
- 不要过早优化
- 保持代码可读性

### 11.3 资源清理

- 确保资源被正确释放（连接、文件、锁等）
- 使用 `defer` 确保清理

**示例：**
```go
func (c *Connection) Close() error {
    defer func() {
        // 清理资源
        c.parser = nil
        c.encoder = nil
    }()
    return c.conn.Close()
}
```

---

## 12. 工具推荐

### 12.1 代码检查工具

```bash
# 代码格式
go fmt ./...

# 代码风格
golint ./...

# 静态分析
go vet ./...

# 更严格的静态分析
staticcheck ./...
```

### 12.2 性能分析工具

```bash
# CPU 性能分析
go test -cpuprofile=cpu.prof -bench=.

# 内存分析
go test -memprofile=mem.prof -bench=.

# 查看分析结果
go tool pprof cpu.prof
```

### 12.3 测试工具

```bash
# 运行测试
go test ./...

# 运行测试并显示覆盖率
go test -cover ./...

# 生成覆盖率报告
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out
```

---

**文档版本**：v1.0  
**创建日期**：2024  
**维护者**：redisX 项目组  
**关联文档**：
- 《技术原理分析.md》
- 《技术实施可行性分析.md》
- 《第一阶段实施计划.md》
- 《技术架构设计.md》

