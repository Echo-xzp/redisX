# 技术架构设计文档

## 文档说明

本文档详细描述 redisX 项目的技术架构设计，包括系统架构、模块设计、接口定义、数据流等。本文档服务于第一阶段的开发实现。

**项目名称**：redisX  
**技术栈**：Go 语言  
**架构版本**：v1.0（第一阶段 MVP）  

---

## 1. 系统架构概述

### 1.1 整体架构

redisX 采用分层架构设计，自下而上分为：存储层、命令层、协议层、网络层。

```
┌─────────────────────────────────────────────────────────┐
│                    客户端层                               │
│  (redis-cli, go-redis, redis-py, jedis 等)              │
└───────────────────────┬─────────────────────────────────┘
                        │ TCP + RESP 协议
┌───────────────────────▼─────────────────────────────────┐
│                     网络层                                │
│  ┌──────────────────────────────────────────────────┐  │
│  │  TCP Server                                       │  │
│  │  - 监听端口（默认 6379）                           │  │
│  │  - 接受客户端连接                                  │  │
│  │  - 连接管理（连接池、超时、关闭）                   │  │
│  └──────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────┐  │
│  │  连接处理器 (Connection Handler)                  │  │
│  │  - 每个连接一个 goroutine                         │  │
│  │  - 读取客户端请求                                  │  │
│  │  - 写入响应                                       │  │
│  └──────────────────────────────────────────────────┘  │
└───────────────────────┬─────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────┐
│                     协议层                                │
│  ┌──────────────────────────────────────────────────┐  │
│  │  RESP 解析器 (RESP Parser)                       │  │
│  │  - 解析请求（数组、字符串、整数等）                │  │
│  │  - 错误处理                                       │  │
│  └──────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────┐  │
│  │  RESP 编码器 (RESP Encoder)                      │  │
│  │  - 编码响应（字符串、整数、错误等）                │  │
│  └──────────────────────────────────────────────────┘  │
└───────────────────────┬─────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────┐
│                     命令层                                │
│  ┌──────────────────────────────────────────────────┐  │
│  │  命令路由器 (Command Router)                     │  │
│  │  - 命令注册                                       │  │
│  │  - 命令路由                                       │  │
│  │  - 参数验证                                       │  │
│  └──────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────┐  │
│  │  命令处理器 (Command Handlers)                   │  │
│  │  - SET/GET/DEL/EXISTS                            │  │
│  │  - EXPIRE/TTL                                    │  │
│  │  - PING/QUIT/INFO                                │  │
│  └──────────────────────────────────────────────────┘  │
└───────────────────────┬─────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────┐
│                     存储层                                │
│  ┌──────────────────────────────────────────────────┐  │
│  │  存储引擎 (Storage Engine)                       │  │
│  │  - 键值存储（map[string]*Entry）                  │  │
│  │  - 线程安全（sync.RWMutex）                       │  │
│  │  - 基础操作（Get/Set/Delete/Exists）              │  │
│  └──────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────┐  │
│  │  过期管理 (Expiration Manager)                    │  │
│  │  - 过期时间记录                                   │  │
│  │  - 懒删除（访问时检查）                            │  │
│  │  - 定期清理（后台 goroutine，可选）                │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

### 1.2 架构设计原则

1. **分层解耦**：各层职责清晰，通过接口交互
2. **并发安全**：存储层使用锁机制保证线程安全
3. **扩展性**：命令系统设计为可扩展，便于添加新命令
4. **性能优先**：第一阶段的架构为后续性能优化预留空间

---

## 2. 模块详细设计

### 2.1 网络层 (Network Layer)

#### 2.1.1 模块职责

- TCP 服务器启动和管理
- 客户端连接接收和管理
- 连接生命周期管理（建立、关闭、超时）
- 请求读取和响应写入的协调

#### 2.1.2 核心组件

**Server**
```go
type Server struct {
    addr     string           // 监听地址，如 ":6379"
    listener net.Listener     // TCP 监听器
    handler  *CommandRouter   // 命令路由器
    conns    sync.Map         // 活跃连接管理（可选）
}

// 核心方法
func (s *Server) Start() error          // 启动服务器
func (s *Server) Stop() error           // 停止服务器
func (s *Server) handleConnection(conn net.Conn)  // 处理单个连接
```

**Connection**
```go
type Connection struct {
    conn     net.Conn         // 原始 TCP 连接
    server   *Server          // 所属服务器
    parser   *RESPParser      // RESP 解析器
    encoder  *RESPEncoder     // RESP 编码器
}

// 核心方法
func (c *Connection) readRequest() ([]string, error)  // 读取并解析请求
func (c *Connection) writeResponse(resp interface{}) error  // 写入响应
func (c *Connection) Close() error                    // 关闭连接
```

#### 2.1.3 并发模型

- **goroutine per connection**：每个客户端连接由独立的 goroutine 处理
- 优点：实现简单，代码清晰
- 缺点：大量连接时 goroutine 开销较大（第一阶段可接受，后续可优化为 epoll 或连接池）

#### 2.1.4 数据流

```
客户端请求 → TCP Socket → Connection.readRequest() 
  → RESP Parser → CommandRouter → Command Handler 
  → Storage → Response → RESP Encoder → Connection.writeResponse() 
  → TCP Socket → 客户端响应
```

---

### 2.2 协议层 (Protocol Layer)

#### 2.2.1 模块职责

- RESP（Redis Serialization Protocol）协议解析
- 请求数据解析为命令和参数
- 响应数据编码为 RESP 格式

#### 2.2.2 RESP 协议支持

**第一阶段支持的 RESP 类型：**

1. **简单字符串（Simple String）**：`+OK\r\n`
2. **错误（Error）**：`-ERR message\r\n`
3. **整数（Integer）**：`:100\r\n`
4. **批量字符串（Bulk String）**：`$5\r\nhello\r\n` 或 `$-1\r\n`（nil）
5. **数组（Array）**：`*2\r\n$3\r\nGET\r\n$3\r\nkey\r\n`

#### 2.2.3 核心组件

**RESPParser**
```go
type RESPParser struct {
    reader *bufio.Reader
}

// 核心方法
func (p *RESPParser) Parse() (interface{}, error)        // 解析单个 RESP 对象
func (p *RESPParser) ParseArray() ([]string, error)      // 解析数组为字符串数组
func (p *RESPParser) parseBulkString() (string, error)   // 解析批量字符串
func (p *RESPParser) parseInt() (int64, error)           // 解析整数
```

**RESPEncoder**
```go
type RESPEncoder struct {
    writer *bufio.Writer
}

// 核心方法
func (e *RESPEncoder) Encode(value interface{}) error    // 编码任意值
func (e *RESPEncoder) EncodeString(s string) error       // 编码字符串
func (e *RESPEncoder) EncodeError(err error) error       // 编码错误
func (e *RESPEncoder) EncodeInt(n int64) error           // 编码整数
func (e *RESPEncoder) EncodeNull() error                 // 编码 nil
func (e *RESPEncoder) Flush() error                      // 刷新缓冲区
```

#### 2.2.4 协议解析流程

```
1. 读取第一个字节，确定 RESP 类型
2. 根据类型解析：
   - '+' → 简单字符串
   - '-' → 错误
   - ':' → 整数
   - '$' → 批量字符串（先读长度，再读内容）
   - '*' → 数组（先读长度，递归解析每个元素）
3. 验证格式（\r\n 结尾）
4. 返回解析结果或错误
```

---

### 2.3 命令层 (Command Layer)

#### 2.3.1 模块职责

- 命令注册和管理
- 命令路由（将命令名映射到处理函数）
- 参数验证和错误处理
- 命令执行和响应生成

#### 2.3.2 核心组件

**CommandRouter**
```go
type CommandHandler func(args []string) (interface{}, error)

type CommandRouter struct {
    commands map[string]CommandHandler
    storage  *Storage
}

// 核心方法
func (r *CommandRouter) Register(name string, handler CommandHandler)  // 注册命令
func (r *CommandRouter) Execute(cmd string, args []string) (interface{}, error)  // 执行命令
func (r *CommandRouter) Route(request []string) (interface{}, error)   // 路由请求
```

**命令注册示例：**
```go
router.Register("SET", cmdSet)
router.Register("GET", cmdGet)
router.Register("DEL", cmdDel)
router.Register("EXISTS", cmdExists)
router.Register("EXPIRE", cmdExpire)
router.Register("TTL", cmdTTL)
router.Register("PING", cmdPing)
router.Register("QUIT", cmdQuit)
router.Register("INFO", cmdInfo)
```

#### 2.3.3 命令处理器签名

所有命令处理器遵循统一签名：
```go
func cmdXXX(args []string, storage *Storage) (interface{}, error)
```

**返回值类型：**
- `string`：编码为简单字符串 `+value\r\n`
- `int64`：编码为整数 `:value\r\n`
- `nil`：编码为 `$-1\r\n`
- `error`：编码为错误 `-ERR message\r\n`
- `[]string`：编码为数组（用于 INFO 等命令）

#### 2.3.4 命令实现示例

**SET 命令：**
```go
func cmdSet(args []string, storage *Storage) (interface{}, error) {
    if len(args) != 2 {
        return nil, errors.New("ERR wrong number of arguments for 'set' command")
    }
    key, value := args[0], args[1]
    storage.Set(key, value, nil)
    return "OK", nil
}
```

**GET 命令：**
```go
func cmdGet(args []string, storage *Storage) (interface{}, error) {
    if len(args) != 1 {
        return nil, errors.New("ERR wrong number of arguments for 'get' command")
    }
    value, exists := storage.Get(args[0])
    if !exists {
        return nil, nil  // nil 表示键不存在
    }
    return value, nil
}
```

---

### 2.4 存储层 (Storage Layer)

#### 2.4.1 模块职责

- 键值对存储和管理
- 线程安全的并发访问
- 过期时间管理和过期键清理
- 基础操作的原子性保证

#### 2.4.2 核心数据结构

**Entry（值对象）**
```go
type Entry struct {
    Value      string     // 存储的值（第一阶段仅支持字符串）
    ExpireTime *time.Time // 过期时间，nil 表示永不过期
}
```

**Storage（存储引擎）**
```go
type Storage struct {
    mu   sync.RWMutex           // 读写锁，保证并发安全
    data map[string]*Entry      // 键值存储
}

// 核心方法
func (s *Storage) Get(key string) (string, bool)              // 获取值
func (s *Storage) Set(key string, value string, expire *time.Time)  // 设置值
func (s *Storage) Delete(key string) bool                     // 删除键
func (s *Storage) Exists(key string) bool                     // 检查键是否存在
func (s *Storage) Expire(key string, seconds int64) bool      // 设置过期时间
func (s *Storage) TTL(key string) int64                       // 获取剩余过期时间
func (s *Storage) Size() int                                  // 获取键数量
```

#### 2.4.3 并发安全策略

- **读写锁（RWMutex）**：
  - 读操作（Get、Exists、TTL）：使用 `RLock()`，允许多个读并发
  - 写操作（Set、Delete、Expire）：使用 `Lock()`，独占访问

- **锁粒度**：
  - 第一阶段：整个 map 一把锁（简单但可能成为瓶颈）
  - 后续优化：分段锁（sharding）或无锁哈希表

#### 2.4.4 过期机制设计

**懒删除（Lazy Deletion）**：
- 在访问键时（Get、Exists、TTL）检查是否过期
- 如果过期，立即删除并返回不存在
- 优点：实现简单，不占用额外资源
- 缺点：过期键可能长期占用内存（如果不再被访问）

**定期清理（Active Expiration）**（可选实现）：
```go
// 后台 goroutine，定期扫描并删除过期键
func (s *Storage) startExpirationCleaner(interval time.Duration) {
    ticker := time.NewTicker(interval)
    go func() {
        for range ticker.C {
            s.cleanExpiredKeys()
        }
    }()
}
```

**过期检查逻辑：**
```go
func (e *Entry) IsExpired() bool {
    if e.ExpireTime == nil {
        return false
    }
    return time.Now().After(*e.ExpireTime)
}
```

---

## 3. 数据流设计

### 3.1 请求处理流程

```
1. 客户端发送请求
   ↓
2. Connection.readRequest()
   - 从 TCP Socket 读取数据
   - 调用 RESPParser.ParseArray()
   ↓
3. RESP Parser 解析
   - 读取 RESP 数组格式
   - 解析为字符串数组，如 ["GET", "key"]
   ↓
4. CommandRouter.Route()
   - 提取命令名（第一个元素）
   - 提取参数（剩余元素）
   - 查找命令处理器
   ↓
5. Command Handler 执行
   - 参数验证
   - 调用 Storage 操作
   - 返回结果
   ↓
6. RESP Encoder 编码
   - 将结果编码为 RESP 格式
   ↓
7. Connection.writeResponse()
   - 写入 TCP Socket
   ↓
8. 响应发送到客户端
```

### 3.2 错误处理流程

```
任何阶段出现错误：
  ↓
捕获错误
  ↓
RESP Encoder.EncodeError()
  - 编码为 "-ERR message\r\n"
  ↓
发送错误响应到客户端
  ↓
（通常不关闭连接，继续处理下一个请求）
```

---

## 4. 关键设计决策

### 4.1 并发模型选择

**决策**：goroutine per connection  
**理由**：
- 实现简单，代码清晰
- Go 的 goroutine 开销相对较小
- 第一阶段目标是功能实现，性能优化后续考虑

**后续优化方向**：
- 使用 epoll 或事件循环（类似 Redis）
- 连接池管理
- worker pool 模式

### 4.2 存储结构选择

**决策**：`map[string]*Entry` + `sync.RWMutex`  
**理由**：
- Go 的 map 性能优秀
- 读写锁适合读多写少的场景
- 实现简单，线程安全有保障

**后续优化方向**：
- 分段锁（sharding）
- 无锁哈希表（Lock-Free Hash Table）
- NUMA 感知的数据分布

### 4.3 过期机制选择

**决策**：懒删除为主，可选定期清理  
**理由**：
- 懒删除实现简单，零开销
- 适合第一阶段快速实现
- 定期清理可作为优化项

### 4.4 协议解析策略

**决策**：流式解析（使用 bufio.Reader）  
**理由**：
- 避免一次性读取整个请求到内存
- 支持增量解析
- 内存效率高

---

## 5. 接口定义

### 5.1 存储层接口

```go
type Storage interface {
    Get(key string) (string, bool)
    Set(key string, value string, expire *time.Time)
    Delete(key string) bool
    Exists(key string) bool
    Expire(key string, seconds int64) bool
    TTL(key string) int64
    Size() int
}
```

### 5.2 命令处理器接口

```go
type CommandHandler func(args []string, storage *Storage) (interface{}, error)
```

### 5.3 协议解析器接口

```go
type Parser interface {
    Parse() (interface{}, error)
    ParseArray() ([]string, error)
}
```

### 5.4 协议编码器接口

```go
type Encoder interface {
    Encode(value interface{}) error
    EncodeString(s string) error
    EncodeError(err error) error
    EncodeInt(n int64) error
    EncodeNull() error
    Flush() error
}
```

---

## 6. 配置管理

### 6.1 配置项（第一阶段）

```go
type Config struct {
    Addr         string        // 监听地址，默认 ":6379"
    MaxConnections int         // 最大连接数，默认 1000
    LogLevel     string        // 日志级别，默认 "info"
    ExpireCleanInterval time.Duration  // 过期清理间隔，默认 1 分钟
}
```

### 6.2 配置加载

- 第一阶段：硬编码或环境变量
- 后续：支持配置文件（JSON/YAML/TOML）

---

## 7. 日志设计

### 7.1 日志级别

- **DEBUG**：详细的调试信息（开发阶段）
- **INFO**：一般信息（服务器启动、连接建立等）
- **WARN**：警告信息（连接异常、命令错误等）
- **ERROR**：错误信息（严重错误、panic 等）

### 7.2 日志输出

- 第一阶段：使用标准库 `log` 或 `fmt.Println`
- 可选：使用第三方库如 `logrus` 或 `zap`

---

## 8. 性能优化预留

### 8.1 第一阶段可实现的优化

1. **数据对齐**（如果时间允许）
   - 对 Entry 结构体进行缓存行对齐
   - 使用 padding 避免伪共享

2. **内存池**（如果时间允许）
   - 使用 `sync.Pool` 为 Entry 对象实现对象池
   - 减少 GC 压力

### 8.2 后续阶段优化方向

1. **无锁数据结构**：替换锁保护的 map
2. **批处理模式**：批量处理请求
3. **NUMA 感知**：多插槽系统优化
4. **大页内存**：减少 TLB 未命中
5. **CPU 亲和性绑定**：减少上下文切换

---

## 9. 扩展性设计

### 9.1 添加新命令

1. 实现命令处理函数（遵循 `CommandHandler` 签名）
2. 在服务器启动时注册命令：`router.Register("NEWCMD", cmdNewCmd)`
3. 无需修改其他模块

### 9.2 添加新数据结构

- 第一阶段仅支持字符串类型
- 后续扩展：在 Entry 中增加类型字段，支持不同类型值

### 9.3 添加持久化

- 存储层预留接口
- 后续实现：RDB 快照或 AOF 日志

---

## 10. 错误处理策略

### 10.1 错误类型

1. **协议错误**：RESP 格式错误 → 返回 `-ERR protocol error`
2. **命令错误**：命令不存在、参数错误 → 返回 `-ERR message`
3. **存储错误**：内存不足等（第一阶段基本不会出现）
4. **网络错误**：连接断开 → 关闭连接，记录日志

### 10.2 错误恢复

- 协议错误：记录日志，返回错误响应，不关闭连接
- 命令错误：返回错误响应，继续处理下一个请求
- 网络错误：关闭连接，清理资源
- Panic：捕获并记录，尝试恢复（第一阶段可简单处理）

---

## 11. 测试策略

### 11.1 单元测试

- **协议层**：RESP 解析器和编码器的各种情况
- **存储层**：并发安全、过期机制
- **命令层**：各命令的正常和异常情况

### 11.2 集成测试

- 使用 redis-cli 手动测试
- 使用 Go 的 go-redis 客户端测试
- 并发连接和并发操作测试

### 11.3 性能测试

- 使用 redis-benchmark 进行基准测试
- 记录 QPS、延迟等指标

---

**文档版本**：v1.0  
**创建日期**：2024  
**维护者**：redisX 项目组  
**关联文档**：
- 《技术原理分析.md》
- 《技术实施可行性分析.md》
- 《第一阶段实施计划.md》
- 《编码规范.md》

